
<!DOCTYPE html>
<html lang="ja">
<!-- https://gist.github.com/Cartman0/436459b9b85cfdd1ca9c -->
<head>
	<meta charset="UTF-8">
	<title>ガッツでC.G.サポートツール</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="gutsdecg.css">
	<style>
      html, body{
        text-align: center;
        background-color: #fafafa;
        font-size: 20px;
        color: #333;
      }
    .content{
        position: relative;
        width: 640px;
        height: 480px;
        border: 1px solid #333;
    }
    .canvas{
        position: absolute;
        top: 0px;
        left: 0px;
        user-select: none;
    }
    .canvasNone{
        position: absolute;
        top: 0px;
        left: 0px;
        user-select: none;
        display: none;
    }
	</style>
  <script src="scanlineseedfillpaint.js"></script>
</head>
<body>
  <center>
      <!-- fileボタンの装飾 https://qiita.com/yasumodev/items/c9f8e8f588ded6b179c9-->
    <div id="fileMemu" class="menu" style="background:#ffeeee; padding:10px; border:1px solid #00ff00; border-radius:10px; width:600px; ">
        <div id="CLEAR_DATA" class="normal_btn" onclick="clearData()"> データ消去 </div>
        <label for="dataFile">
            データファイル読込<input type="file" name="dataFile" id="dataFile" style="display:none;">
         </label>
        <label for="imageFile">
            参考画像読込<input type="file" name="imageFile" id="imageFile" style="display:none;">
        </label>
        <div id="IMAGE_ALPHA" class="normal_btn" onclick="changeImageAlpha()"> 50% </div>
        </div>

    <div id="fileMemu" class="menu" style="background:#ffeeee; padding:10px; border:1px solid #00ff00; border-radius:10px; width:600px; ">
        <div id="EXEC_COPY" class="normal_btn" onclick="execCopy()"> データをクリップボードにコピー </div>
        <div id="SAVE_DATA" class="normal_btn" onclick="saveData()"> データをファイルに保存 </div>
     </div>

  <br/>
  
     <div id="simpleMenu" class="menu" style="background:#ffeeee; padding:10px; border:1px solid #ff0000; border-radius:10px; width:600px; ">
        <div id="LINE_BUTTON" class="selected_btn" onclick="changeLINE()"> 線を引く </div>
        <div id="PAINT_BUTTON" class="normal_btn" onclick="changePAINT()"> 色塗り </div>
        <div id="AFTER_LINE_BUTTON" class="normal_btn" onclick="changeAFTERLINE()"> 後の線を引く </div>
        <div id="LAST_PAINT_BUTTON" class="normal_btn" onclick="changeLASTPAINT()"> 仕上げ塗り </div>
        <div id="CHANGE_DELETE_BUTTON" class="sp_normal_btn" onclick="changeDeleteMode()"> 削除 </div>
    </div>
    <br/>
    <div id="advancedMenu"  class="menu" style="background:#ffeeee; padding:10px; border:1px solid #ff0000; border-radius:10px;width:600px;">
        <div id="SELECTED_COLOR" class="selected_color" style="background:#000000; border:1px solid #000000;width:20px">　</div>
        <div id="SPOIT_BUTTON" class="normal_btn" onclick="spoitON()"> 画像の色を取得 </div>
        <div id="PAINT_FILL_BUTTON" class="normal_btn" onclick="changePaintFillMode()"> 塗らないモード </div>
        <div id="UNDO_BUTTON" class="normal_btn" onclick="undo()"> UNDO[線を引く] </div>
    </div>

  <br/>
  
  
  
  <div class="content">
	<div class="canvas">
		<canvas id="imageLayer" width="640" height="480"></canvas>
    </div>
      <div class="canvas"><canvas id="alphaLayer" width="640" height="480"></canvas>
    </div>
    <div class="canvas"><canvas width="640" height="480" id="mycanvas">Canvasに対応したブラウザを用意して下さい。</canvas></div>
    <div class="canvas"><canvas width="640" height="480" id="lastPaintCanvas"></canvas></div>
  </div>

  <div id="info"></div>
  <div id="simpleMenu" class="menu" style="background:#ffeeee; padding:10px; border:1px solid #ff0000; border-radius:10px;width:600px;">
    <div class="selected_color" style="background:#000000; border:1px solid #000000;width:20px" onclick="setColor('000000')">　</div>
    <div class="selected_color" style="background:#ff0000; border:1px solid #000000;width:20px" onclick="setColor('ff0000')">　</div>
    <div class="selected_color" style="background:#0000ff; border:1px solid #000000;width:20px" onclick="setColor('0000ff')">　</div>
    <div class="selected_color" style="background:#ff00ff; border:1px solid #000000;width:20px" onclick="setColor('ff00ff')">　</div>
    <div class="selected_color" style="background:#00ff00; border:1px solid #000000;width:20px" onclick="setColor('00ff00')">　</div>
    <div class="selected_color" style="background:#00ffff; border:1px solid #000000;width:20px" onclick="setColor('00ffff')">　</div>
    <div class="selected_color" style="background:#ffff00; border:1px solid #000000;width:20px" onclick="setColor('ffff00')">　</div>
    <div class="selected_color" style="background:#ffffff; border:1px solid #000000;width:20px" onclick="setColor('ffffff')">　</div>
</div>
<div id="simpleMenu" class="menu" style="background:#ffeeee; padding:10px; border:1px solid #ff0000; border-radius:10px; width:600px; ">
    CGタイトル：<input type="text" id="CG_TITLE" size="20"/>
</div>
</center>
<script>
    //定数
    const DMODE_LINE = 0
    const DMODE_PAINT = 1
    const DMODE_AFTER_LINE = 2
    const DMODE_LAST_PAINT = 3

    //描画データ
    var drawDataList = []; //線のリスト list[color, list[位置x,y]]
    var paintDataList = []; //ペイントデータのリスト。list[color, 位置x,y]
    var afterDrawDataList = [];//ペイント後に引く線のリスト list[color, list[位置x,y]]
    var lastPaintDataList = [];//ペイント後に引く線のリスト list[color, list[位置x1,y1,x2,y2]]
    var curDrawData = []; //現在の線のリスト

    var penColor = '000000';//現在のペンの色
    
    var drawMode = DMODE_LINE; //現在のモード 0:draw 1:paint
    var isSpoit = false; //スポイトモード
    var isPaintFill = false; //ペイント塗りつぶしモード
    var colorMode = SELECTED_COLOR;
    var isDelete = false;//削除モード
    var imageAplhaMode = 0;
    var doLastPaint = false;

    var backGroundColor = "FFFFFF";
    var cgTitle = "";

    var imageFileForm = document.getElementById('imageFile');
    imageFileForm.addEventListener('change', loadImage, false);
    
    var dataFileForm = document.getElementById('dataFile');
    dataFileForm.addEventListener('change', loadData, false);
    
    var lineButtonObj = document.getElementById('LINE_BUTTON');
    var paintButtonObj = document.getElementById('PAINT_BUTTON');
    var afterLineButtonObj = document.getElementById('AFTER_LINE_BUTTON');
    var lastPaintButtonObj = document.getElementById('LAST_PAINT_BUTTON');
    
    var selectedColorObj = document.getElementById('SELECTED_COLOR');
    var spoitButtonObj = document.getElementById('SPOIT_BUTTON');
    var paintFillButtonButtonObj = document.getElementById('PAINT_FILL_BUTTON');
    var undoButtonObj = document.getElementById('UNDO_BUTTON');
    var changeDeleteButtonObj = document.getElementById('CHANGE_DELETE_BUTTON');
    var imageAlphaButtonObj = document.getElementById('IMAGE_ALPHA');
    
    var cgTitleForm = document.getElementById('CG_TITLE');
    cgTitleForm.value = cgTitle;
    cgTitleForm.addEventListener('change', changeCgTitle, false);

    var selectRect = {
        startY:0,
        startX:0,
        endY:0,
        endX:0,
        clear:function () {
            this.startY = 0;
            this.startX = 0;
            this.endY   = 0;
            this.endX   = 0;
        }
    };
    var borderWidth = 1;
    var smallMode = false;
      (function(){
        window.onload = function(){
          var canvas = document.getElementById('mycanvas');
          if(!canvas || !canvas.getContext){
            return false;
          }
          var ctx = canvas.getContext('2d');

          //ポインタの座標を取得
          var mouse = {
            startX: -1,
            startY: -1,
            x: 0,
            y: 0,
            color: "black",
            isDrawing: false
          };

          canvas.addEventListener("mousemove", function(e){
            //2.ポインタが動いたら座標値を取得
                var rect = e.target.getBoundingClientRect();
                mouse.x = e.clientX - rect.left - borderWidth;
                if(mouse.x < 0){mouse.x = 0;}
                mouse.y = e.clientY - rect.top - borderWidth;
                if(mouse.y < 0){mouse.y = 0;}
                /*
                pageX[Y], offsetLeft[Top]を使う場合
                mouse.x = e.pageX - canvas.offsetLeft - borderWidth;
                mouse.y = e.pageY - canvas.offsetTop - borderWidth;
                */

            //4.isDrawがtrueのとき描画
                if (isDelete == false && isSpoit == false && mouse.isDrawing && (drawMode == DMODE_LINE || drawMode ==DMODE_AFTER_LINE)){
                    ctx.beginPath();
                    ctx.moveTo(mouse.startX, mouse.startY);
                    ctx.lineTo(mouse.x, mouse.y);
                   	ctx.strokeStyle = "#" + penColor
                    ctx.stroke();
                    mouse.startX = mouse.x;
                    mouse.startY = mouse.y;
                    //drawData = drawData + "," + Math.round(mouse.x) + "," + Math.round(mouse.y)
                    var point = [Math.round(mouse.x),Math.round(mouse.y)];
                    curDrawData.push(point);
                    //document.getElementById("drawData").innerHTML = drawData;
                }
                //3.情報をinfoに出力
                document.getElementById("info").innerHTML =
                " canvas x座標 = " + Math.floor(mouse.x) + "px" +
                " canvas y座標 = " + Math.floor(mouse.y) + "px" + '<br>' +
                //" データ量 = " + drawData.length + '<br>'+
                " リスト量 = " + drawDataList.length + ":" + paintDataList.length + ":" + afterDrawDataList.length + '<br>';

          });

          //5.ポインタを押したら、描画OK(myDrawをtrue)
          canvas.addEventListener("mousedown", function(e){
            var rect = e.target.getBoundingClientRect();
            mouse.x = e.clientX - rect.left - borderWidth;
            if(mouse.x < 0){mouse.x = 0;}
            mouse.y = e.clientY - rect.top - borderWidth;
            if(mouse.y < 0){mouse.y = 0;}

            if(isSpoit){
                mouse.isDrawing = false;
                //スポイトモード
                setColor(getColor(mouse.x,mouse.y));
                return;
            }
            if(isDelete){
                mouse.isDrawing = false;
                //該当のポイントを消す処理
                deletePoint(mouse.x, mouse.y);
                return;
            }
            if(drawMode == DMODE_LINE || drawMode ==DMODE_AFTER_LINE){
                mouse.isDrawing = true;
                mouse.startX = mouse.x;
                mouse.startY = mouse.y;
                curDrawData = [];
                var point = [Math.round(mouse.x),Math.round(mouse.y)];
                curDrawData.push(point);
                //window.alert("mouse down x:" + mouse.x + " y:" + mouse.y)
                //document.getElementById("drawData").innerHTML = drawData;
            }else{
                //PAINT情報を付与
                paint(mouse.x,mouse.y)
            }
          });

          //6.ポインタを上げたら、描画禁止(myDrawをfalse)
            canvas.addEventListener("mouseup", function(e){
                if(isSpoit){
                    mouse.isDrawing = false;
                    //スポイトモード
                    spoitOFF();                    
                    return;
                }
                if(isDelete){
                    mouse.isDrawing = false;
                    return;
                }
                if(drawMode == DMODE_LINE || drawMode ==DMODE_AFTER_LINE){
                    mouse.isDrawing = false;
                //    drawData = drawData + ",-1\n";
                    //document.getElementById("drawData").innerHTML = drawData;
                    if(curDrawData.length > 0){
	                    var drawDataObj = {color: penColor , drawData:curDrawData}
	                    if(drawMode == DMODE_LINE){
	                        drawDataList.push(drawDataObj);
	                    }else{
	                        afterDrawDataList.push(drawDataObj);
	                    }
	                }
                    curDrawData = [];
                    redraw();
                }
            });

          canvas.addEventListener('mouseleave', function(e){
            if(isSpoit){
                    mouse.isDrawing = false;
                    //スポイトモード
                    spoitOFF();                    
                    return;
                }
                if(isDelete){
                    mouse.isDrawing = false;
                    return;
                }
                if(drawMode == DMODE_LINE || drawMode ==DMODE_AFTER_LINE){
                    mouse.isDrawing = false;
                //    drawData = drawData + ",-1\n";
                    //document.getElementById("drawData").innerHTML = drawData;
                    if(curDrawData.length > 0){
	                    var drawDataObj = {color: penColor , drawData:curDrawData}
	                    if(drawMode == DMODE_LINE){
	                        drawDataList.push(drawDataObj);
	                    }else{
	                        afterDrawDataList.push(drawDataObj);
	                    }
	                }
                    curDrawData = [];
                    redraw();
                }
            });
          
          
          canvas.addEventListener("touchstart", function(e){
            if(event.targetTouches.length != 1){ //2本以上でタッチされたときは無視
               return;
            }
            var rect = e.target.getBoundingClientRect();
            mouse.x = e.touches[0].clientX - rect.left - borderWidth;
            mouse.y = e.touches[0].clientY - rect.top - borderWidth;
            if(mouse.x < 0){mouse.x = 0;}
            if(mouse.y < 0){mouse.y = 0;}
            
            mouse.startX = mouse.x
            mouse.startY = mouse.y
            if(isSpoit){
                //スポイトモード
                setColor(getColor(mouse.x,mouse.y));
                return;
            }
            if(isDelete){
                //該当のポイントを消す処理
                deletePoint(mouse.x, mouse.y);
                return;
            }
            if(drawMode == DMODE_LINE || drawMode ==DMODE_AFTER_LINE){
                mouse.isDrawing = true;
                curDrawData = [];
                var point = [Math.round(mouse.x),Math.round(mouse.y)];
                curDrawData.push(point);
                //window.alert("touch start x:" + mouse.x + " y:" + mouse.y)
                //document.getElementById("drawData").innerHTML = drawData;
            }else{
                //PAINT情報を付与
                paint(mouse.x,mouse.y)
            }
          });
        
          canvas.addEventListener("touchmove", function(e){
            if(event.targetTouches.length != 1){ //2本以上でタッチされたときは無視
               return;
            }
            e.preventDefault(); // タッチによる画面スクロールを止める
            //タッチが動いたら座標値を取得
                var rect = e.target.getBoundingClientRect();
                mouse.x = e.touches[0].clientX - rect.left - borderWidth;
                mouse.y = e.touches[0].clientY - rect.top - borderWidth;
                if(mouse.x < 0){mouse.x = 0;}
                if(mouse.y < 0){mouse.y = 0;}
                
                if(isDelete == false && isSpoit==false &&(drawMode == DMODE_LINE || drawMode ==DMODE_AFTER_LINE)){
                     ctx.beginPath();
                     ctx.moveTo(mouse.startX, mouse.startY);
                     ctx.lineTo(mouse.x, mouse.y);
                     ctx.strokeStyle = "#" + penColor
                     ctx.stroke();
                     //drawData = drawData + "," + Math.round(mouse.x) + "," + Math.round(mouse.y)
                     //document.getElementById("drawData").innerHTML = drawData;
                     var point = [Math.round(mouse.x),Math.round(mouse.y)];
                    curDrawData.push(point);

                 }
                mouse.startX = mouse.x;
                mouse.startY = mouse.y;

            //情報をinfoに出力
                document.getElementById("info").innerHTML =
                " canvas x座標 = " + Math.floor(mouse.x) + "px" +
                " canvas y座標 = " + Math.floor(mouse.y) + "px" + '<br>' + 
                " リスト量 = " + drawDataList.length + ":" + paintDataList.length + ":" + afterDrawDataList.length + '<br>';

          });

          canvas.addEventListener("touchend", function(e){
            if(isSpoit){
                //スポイトモード
                mouse.isDrawing = false;
                spoitOFF();                    
                return;
            }
            if(isDelete){
                mouse.isDrawing = false;
                return;
            }
              if(drawMode == DMODE_LINE || drawMode ==DMODE_AFTER_LINE){
                mouse.isDrawing = false;
                //drawData = drawData + ",-1\n";
                //document.getElementById("drawData").innerHTML = drawData;
                if(curDrawData.length > 0){
	                var drawDataObj = {color: penColor , drawData:curDrawData}
	                if(drawMode == DMODE_LINE){
	                    drawDataList.push(drawDataObj);
	                }else{
	                    afterDrawDataList.push(drawDataObj);
	                }
	            }
                curDrawData = [];
                redraw();
             }
          }); 

          var lastPaintCanvas = document.getElementById('lastPaintCanvas');
          if(!lastPaintCanvas || !lastPaintCanvas.getContext){
            return false;
          }
          var ctxLastPaintCanvas = lastPaintCanvas.getContext('2d');
          lastPaintCanvas.addEventListener("mousedown", function(e) {
            var rect = e.target.getBoundingClientRect();
            selectRect.startX = Math.floor(e.clientX - rect.left - borderWidth);
            if(selectRect.startX < 0){selectRect.startX = 0;}
            selectRect.startY = Math.floor(e.clientY - rect.top - borderWidth);
            if(selectRect.startY < 0){selectRect.startY = 0;}

            selectRect.endX = selectRect.startX;
            selectRect.endY = selectRect.startY;
            if(isSpoit){
                //スポイトモード
                setColor(getColor(selectRect.startX,selectRect.startY));
                return;
            }
            if(isDelete){
                //該当のポイントを消す処理
                deletePoint(selectRect.startX,selectRect.startY);
                return;
            }
            doLastPaint = true;
            lastPaintCanvas.addEventListener ("mousemove", onMouseMoveLastPaint, false);
          });
       
          lastPaintCanvas.addEventListener("mouseup", function(e) {
            if(isSpoit){
                //スポイトモード
                spoitOFF();                    
                return;
            }
            if(doLastPaint == false){
                return;
            }
              //データとしてはwidth,heightではなくて、すべて座標で持つ
                lastPaintDataObj = [penColor,selectRect.startX,selectRect.startY,
                                    selectRect.startX + selectRect.endX,selectRect.startY + selectRect.endY];
                lastPaintDataList.push(lastPaintDataObj);
                selectRect.clear();
                ctxLastPaintCanvas.clearRect(0, 0, 640, 480);
                lastPaintCanvas.removeEventListener ("mousemove", onMouseMoveLastPaint, false);
                redraw();
                doLastPaint = false;
          });

          lastPaintCanvas.addEventListener("touchstart", function(e) {
            if(event.targetTouches.length != 1){ //2本以上でタッチされたときは無視
               return;
            }
            var rect = e.target.getBoundingClientRect();
            selectRect.startX = Math.floor(e.touches[0].clientX - rect.left - borderWidth);
            if(selectRect.startX < 0){selectRect.startX = 0;}
            selectRect.startY = Math.floor(e.touches[0].clientY - rect.top - borderWidth);
            if(selectRect.startY < 0){selectRect.startY = 0;}

            selectRect.endX = selectRect.startX;
            selectRect.endY = selectRect.startY;
            if(isSpoit){
                //スポイトモード
                setColor(getColor(selectRect.startX,selectRect.startY));
                return;
            }
            if(isDelete){
                //該当のポイントを消す処理
                deletePoint(selectRect.startX,selectRect.startY);
                return;
            }
            doLastPaint = true;
            lastPaintCanvas.addEventListener ("touchmove", onTouchMoveLastPaint, false);
          });

          lastPaintCanvas.addEventListener("touchend", function(e) {
            if(isSpoit){
                //スポイトモード
                spoitOFF();                    
                return;
            }
            if(doLastPaint == false){
                return;
            }
              //データとしてはwidth,heightではなくて、すべて座標で持つ
                lastPaintDataObj = [penColor,selectRect.startX,selectRect.startY,
                                    selectRect.startX + selectRect.endX,selectRect.startY + selectRect.endY];
                lastPaintDataList.push(lastPaintDataObj);
                selectRect.clear();
                ctxLastPaintCanvas.clearRect(0, 0, 640, 480);
                lastPaintCanvas.removeEventListener ("touchmove", onTouchMoveLastPaint, false);
                redraw();
                doLastPaint = false;
          });


          lastPaintOFF();  
        }//onLoad
    })();
      
    function onMouseMoveLastPaint (e) {
        var lastPaintCanvas = document.getElementById('lastPaintCanvas');
        if(!lastPaintCanvas || !lastPaintCanvas.getContext){
           return false;
         }
         var ctxLastPaintCanvas = lastPaintCanvas.getContext('2d');
         ctxLastPaintCanvas.clearRect(0, 0, 640, 480);

         var rect = e.target.getBoundingClientRect();
            selectRect.endX = Math.floor(e.clientX - rect.left - borderWidth - selectRect.startX);
            selectRect.endY = Math.floor(e.clientY - rect.top - borderWidth - selectRect.startY);
            ctxLastPaintCanvas.strokeStyle = "#" + penColor
          ctxLastPaintCanvas.strokeRect (selectRect.startX, selectRect.startY, selectRect.endX, selectRect.endY);
    };

    function onTouchMoveLastPaint (e) {
        if(event.targetTouches.length != 1){ //2本以上でタッチされたときは無視
            return;
        }
        e.preventDefault(); // タッチによる画面スクロールを止める
        var lastPaintCanvas = document.getElementById('lastPaintCanvas');
        if(!lastPaintCanvas || !lastPaintCanvas.getContext){
           return false;
         }
         var ctxLastPaintCanvas = lastPaintCanvas.getContext('2d');
         ctxLastPaintCanvas.clearRect(0, 0, 640, 480);

         var rect = e.target.getBoundingClientRect();
            selectRect.endX = Math.floor(e.touches[0].clientX - rect.left - borderWidth - selectRect.startX);
            selectRect.endY = Math.floor(e.touches[0].clientY - rect.top - borderWidth - selectRect.startY);
            ctxLastPaintCanvas.strokeStyle = "#" + penColor
          ctxLastPaintCanvas.strokeRect (selectRect.startX, selectRect.startY, selectRect.endX, selectRect.endY);
    };

    function clearData(){
              if(!window.confirm("描画データをクリアしますか？")){
                  return
              }
          var canvas = document.getElementById('mycanvas');
          if(!canvas || !canvas.getContext){
            return false;
          }
          var ctx = canvas.getContext('2d');
          drawDataList = []; //線のリスト list[color, list[位置x,y]]
          paintDataList = []; //ペイントデータのリスト。list[color, 位置x,y]
          afterDrawDataList = [];//ペイント後に引く線のリスト list[color, list[位置x,y]]
          lastPaintDataList = [];
          curDrawData = []; //現在の線のリスト
          //document.getElementById("drawData").innerHTML = drawData;
          ctx.clearRect(0, 0, 640, 480);
    }
    function loadImage(e){
      //https://www.tam-tam.co.jp/tipsnote/javascript/post13538.html ローカルファイルのロード
      //https://qiita.com/PG0721/items/599ba2921b8339700fe3 アスペクト比保持読み込み

          //元の画像を保持したまま、表示色を薄くするためのアルファレイヤー
        var alphaLayer = document.getElementById("alphaLayer");
            if(!alphaLayer || !alphaLayer.getContext){
            return false;
        }
        var aplhaLayerCtx = alphaLayer.getContext("2d");
        aplhaLayerCtx.globalAlpha = 0.7;
        aplhaLayerCtx.fillStyle = "white";
        aplhaLayerCtx.clearRect(0, 0, 640, 480);
        aplhaLayerCtx.fillRect(0, 0, aplhaLayerCtx.canvas.width, aplhaLayerCtx.canvas.height);
        imageAplhaMode = 0;
        imageAlphaButtonObj.innerHTML=" 50% "

        var imageLayer = document.getElementById("imageLayer");
        if(!imageLayer || !imageLayer.getContext){
            return false;
        }
        var imageLayerCtx = imageLayer.getContext("2d");

            // ファイル情報を取得
        var fileData = e.target.files[0];
                // 画像ファイル以外は処理を止める
        if(!fileData.type.match('image.*')) {
            alert('画像を選択してください');
            return;
        }
            
        // FileReaderオブジェクトを使ってファイル読み込み
        var reader = new FileReader();
        var img = new Image();
        reader.onload = function() {
              img.src = reader.result;
        }
            
        /* 画像が読み込まれるのを待ってから処理を続行 */
        img.onload = function() {
            var canvasAspect = imageLayerCtx.canvas.width / imageLayerCtx.canvas.height, // canvasのアスペクト比
            imgAspect = img.width / img.height, // 画像のアスペクト比
            left, top, width, height;

            imageLayerCtx.fillStyle = "black";
            imageLayerCtx.fillRect(0, 0, imageLayerCtx.canvas.width, imageLayerCtx.canvas.height);

            if(imgAspect >= canvasAspect) {// 画像が横長
                left = 0;
                width = imageLayerCtx.canvas.width;
                height = imageLayerCtx.canvas.width / imgAspect;
                top = (imageLayerCtx.canvas.height - height) / 2;
            } else {// 画像が縦長
                top = 0;
                height = imageLayerCtx.canvas.height;
                width = imageLayerCtx.canvas.height * imgAspect;
                left = (imageLayerCtx.canvas.width - width) / 2;
            }
            imageLayerCtx.drawImage(img, 0, 0, img.width, img.height, 
                left, top, width, height);
            
        };
        reader.readAsDataURL(fileData);
    }

    function makeCGData(){

        var drawString = "640,480,0x";
        if(backGroundColor.length > 0){
            drawString = drawString + backGroundColor + ",0";
        }else{
            drawString = drawString + "FFFFFF" + ",0";
        }
        
        if(cgTitle.length > 0){
            drawString = drawString + "#" + cgTitle;
        }
        drawString = drawString + "\n";

        //LINEデータ
        if(drawDataList.length>0){
            drawString = drawString + "-10,";
            for(idx = 0;idx < drawDataList.length;idx++){
                var drawDataObj = drawDataList[idx];
                var color = drawDataObj.color;
                if(color == 0){
                    drawString = drawString + "0,";
                }else{
                    drawString = drawString + "0x" + color + ","; 
                }
                for(lineIdx = 0;lineIdx < drawDataObj.drawData.length;lineIdx++){
                    var drawPoint = drawDataObj.drawData[lineIdx];
                    //TODO:前回と動きが少なすぎる場合は間引く？
                    drawString = drawString + drawPoint[0] + "," + drawPoint[1] + ",";
                }
                drawString = drawString + "-1\n";
            }
            drawString = drawString + "-1\n";
        }
            
        //PaintData
        if(paintDataList.length > 0){
            drawString = drawString + "-20,";
            for(idx = 0;idx < paintDataList.length;idx++){
                var paintDataObj = paintDataList[idx];
                var color = paintDataObj[0];
                var x =  paintDataObj[1];
                var y =  paintDataObj[2];
                drawString = drawString + "0x" + paintDataObj[0] + "," + paintDataObj[1] + "," + paintDataObj[2] + ",-1\n";
            }
                drawString = drawString + "-1\n";
            }
        //PAINT後LINEデータ
        if(afterDrawDataList.length > 0){
            drawString = drawString + "-10,";
            for(idx = 0;idx < afterDrawDataList.length;idx++){
                var drawDataObj = afterDrawDataList[idx];
                var color = drawDataObj.color;
                if(color == 0){
                    drawString = drawString + "0,";
                }else{
                    drawString = drawString + "0x" + color + ","; 
                }
                for(lineIdx = 0;lineIdx < drawDataObj.drawData.length;lineIdx++){
                    var drawPoint = drawDataObj.drawData[lineIdx];
                    drawString = drawString + drawPoint[0] + "," + drawPoint[1] + ",";
                }
                drawString = drawString + "-1\n";
            }
            drawString = drawString + "-1\n";
        }
        //LASTPAINT データ
        if(lastPaintDataList.length > 0){
            drawString = drawString + "-30,";
            for(idx = 0;idx < lastPaintDataList.length;idx++){
                var lastPaintDataObj = lastPaintDataList[idx];
                var color = lastPaintDataObj[0];
                if(color == 0){
                    drawString = drawString + "0,";
                }else{
                    drawString = drawString + "0x" + color + ","; 
                }
                drawString = drawString + lastPaintDataObj[1] + "," + lastPaintDataObj[2] + "," + lastPaintDataObj[3] + "," + lastPaintDataObj[4] + ",";
                drawString = drawString + "\n";
            }
            drawString = drawString + "-1\n";
        }


        return drawString;
    }

    function execCopy(){
              //https://qiita.com/simiraaaa/items/2e7478d72f365aa48356
            drawString = makeCGData();
            var temp = document.createElement('div');
            temp.appendChild(document.createElement('pre')).textContent = drawString
            var s = temp.style;
              s.position = 'fixed';
              s.left = '-100%';

            document.body.appendChild(temp);
              document.getSelection().selectAllChildren(temp);

              var result = document.execCommand('copy');

              document.body.removeChild(temp);
              // true なら実行できている falseなら失敗か対応していないか
        return result;
    }


    //http://blog.fagai.net/2014/08/09/javascript-only-save/
    function saveData(){
        drawString = makeCGData();
        var blob = new Blob([drawString], {type: "text/plain"}); // バイナリデータを作ります。

        // IEか他ブラウザかの判定
        if(window.navigator.msSaveBlob)
        {
            // IEなら独自関数を使います。
            window.navigator.msSaveBlob(blob, "pccgdata" + getNowYMDHMS() + ".dat");
        } else {
            // それ以外はaタグを利用してイベントを発火させます
            var a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.target = '_blank';
            a.download = "pccgdata" + getNowYMDHMS() + ".dat";
            a.click();
        }

    }

    function restoreData(cgData){ 
        //読み込み用のリスト
        var newDrawDataList = []; //線のリスト list[color, list[位置x,y]]
        var newPaintDataList = []; //ペイントデータのリスト。list[color, 位置x,y]
        var newAfterDrawDataList = [];//ペイント後に引く線のリスト list[color, list[位置x,y]]
        var newLastPaintDataList = [];
        index = 0;
        var afterPaint = false;//1回でもペイント処理が入ったらTrue
        while(index < cgData.length){

            if (index < 4) {//最初の4つは読み飛ばし640,480,0xFFFFFF,0
                index++;
                continue;
            }
            switch(Number(cgData[index])){
                case -10://LINE
                    index++;
                    //-1がくるまで
                    while(Number(cgData[index]) != -1){
                        curDrawData = [];
                        var color = String(cgData[index]);
                        if(color.length > 2){
                        	//0xから始まっていたら0x取る
                        	if(color.indexOf("0x")==0){
	                            color = color.substring(2);
                        	}
                        }
                        index++;
                        //-1が来るまで
                        while(Number(cgData[index])!=-1){
                            x = Number(cgData[index]);
                            index++;
                            y = Number(cgData[index]);
                            var point = [x,y];
                            curDrawData.push(point);
                            index++;
                        }
                        var drawDataObj = {color: color , drawData:curDrawData};
                        if(afterPaint == false){
                            newDrawDataList.push(drawDataObj);
                        }else{
                            newAfterDrawDataList.push(drawDataObj);
                        }
                        index++;
                    }
                    break;
                case -20://PAINT
                    afterPaint= true;
                    index++;
                    while(Number(cgData[index]) != -1){
                        var color = String(cgData[index]);
                        if(color.length > 2){
                        	//0xから始まっていたら0x取る
                        	if(color.indexOf("0x")==0){
	                            color = color.substring(2);
                        	}
                        }
                        index++;
                        while(Number(cgData[index]) !=-1){
                            x = Number(cgData[index]);
                            index++;
                            y = Number(cgData[index]);
                            paintDataObj = [color,x,y];
                            newPaintDataList.push(paintDataObj);
                            index++;
                        }
                        index++;
                    }
                    break;
                case -30: //LAST PAINT
                    index++;
                    while(Number(cgData[index]) != -1){
                        var color = String(cgData[index]);
                        if(color.length > 2){
                        	//0xから始まっていたら0x取る
                        	if(color.indexOf("0x")==0){
	                            color = color.substring(2);
                        	}
                        }
                        index++;
                        x1 = Number(cgData[index]);
                        index++;
                        y1 = Number(cgData[index]);    
                        index++;
                        x2 = Number(cgData[index]);
                        index++;
                        y2 = Number(cgData[index]);
                        lastPaintDataObj = [color,x1,y1,x2,y2];
                        newLastPaintDataList.push(lastPaintDataObj);
                        index++;
                    }
            }
            index++;
        }
    //ここまで来たら成功   
        drawDataList = newDrawDataList;
        paintDataList = newPaintDataList;
        afterDrawDataList = newAfterDrawDataList;
        lastPaintDataList = newLastPaintDataList;
        redraw();
    }


    function loadData(e){
        if(!window.confirm("データを読み込みますか？")){
            return
        }
        
        var cgData = [];
        var result = e.target.files[0];
 
        //FileReaderのインスタンスを作成する
        var reader = new FileReader();
  
        //読み込んだファイルの中身を取得する
        reader.readAsText( result );
  
        //ファイルの中身を取得後に処理を行う
        reader.onload =function() {
            dataString = reader.result;
            //改行で分割
            var dataLines = dataString.split("\n");

            for(index = 0;index < dataLines.length;index++){
                //T#以降はコメントなので消す 1行目の #以降があればCGタイトル
                dataWithComment =  dataLines[index].split("#");
                if(dataWithComment.length >=2 && index == 0){
                    cgTitle = dataWithComment[1];
                    cgTitleForm.value = cgTitle;
                }
                //カンマで分割
                data = dataWithComment[0].split(",");
                dataResult = [];
                //中身""のところがあったら飛ばす
                for(dataIdx = 0;dataIdx < data.length;dataIdx++){
                    if(data[dataIdx].length > 0){
                        dataResult.push(data[dataIdx]);
                    }
                }
                Array.prototype.push.apply(cgData,dataResult);
            }

            //データ反映
            restoreData(cgData);
        }
    }

    function changeLINE(){
        //LINEモードにする
        drawMode = DMODE_LINE;
        curDrawData = [];
        lineButtonObj.className = "selected_btn";
        paintButtonObj.className = "normal_btn" ;
        afterLineButtonObj.className = "normal_btn" ;
        lastPaintButtonObj.className = "normal_btn"  ;
        undoButtonObj.innerHTML=" UNDO[線を引く] "
        lastPaintOFF();
        spoitOFF();
        redraw();
    }
    function changePAINT(){
        //PAINTモードにする
        drawMode = DMODE_PAINT;
        curDrawData = [];
        lineButtonObj.className = "normal_btn";
        paintButtonObj.className = "selected_btn" ;
        afterLineButtonObj.className = "normal_btn" ;
        lastPaintButtonObj.className = "normal_btn"  ;
        undoButtonObj.innerHTML=" UNDO[色塗り] "
        lastPaintOFF();
        spoitOFF();
        redraw();
    }
    function changeAFTERLINE(){
        //PAINT後LINEモードにする
        drawMode = DMODE_AFTER_LINE;
        curDrawData = [];
        lineButtonObj.className = "normal_btn";
        paintButtonObj.className = "normal_btn" ;
        afterLineButtonObj.className = "selected_btn" ;
        lastPaintButtonObj.className = "normal_btn"  ;
        undoButtonObj.innerHTML=" UNDO[後の線] "
        lastPaintOFF();
        spoitOFF();
        redraw();
    }
    function changeLASTPAINT(){
        drawMode = DMODE_LAST_PAINT;
        lineButtonObj.className = "normal_btn";
        paintButtonObj.className = "normal_btn" ;
        afterLineButtonObj.className = "normal_btn" ;
        lastPaintButtonObj.className = "selected_btn" ;
        undoButtonObj.innerHTML=" UNDO[仕上げ] "
        lastPaintON();
        spoitOFF();
        redraw();

    }

    function paint(x,y){
        x = Math.floor(x);
        y = Math.floor(y);
        //paintColor = getColor(x, y);
        paintColor = penColor;
        //ペイントデータ追加
        //paintData = paintData + ",0x" + paintColor + "," + x + "," + y + "," + "-1\n"
        paintDataObj = [paintColor,x,y];
        paintDataList.push(paintDataObj);

		redraw();
          //描画レイヤーにその色で円を描く
//        var canvas = document.getElementById('mycanvas');
//        if(!canvas || !canvas.getContext){
//            return false;
//        }
//        var ctx = canvas.getContext('2d');
//        ctx.beginPath();
//        ctx.fillStyle = "#" + paintColor;
//        ctx.arc(x, y, 2, 0, Math.PI*2, false);
//        ctx.fill();
    }
      
      //スポイトだけで使う前提！
    function getColor(x,y){ //https://www.petitmonte.com/javascript/get_image_color.html
        //最初に画像レイヤーから色を拾う
        var canvas = document.getElementById('mycanvas');
        if(!canvas || !canvas.getContext){
            return '000000';
        }
        var ctx = canvas.getContext("2d");

        var canvasdata = ctx.getImageData(x, y, 1, 1);
          //  RGBAの取得
        var r = canvasdata.data[0];
        var g = canvasdata.data[1];
        var b = canvasdata.data[2];
        var a = canvasdata.data[3];
        if(a+g+b+a > 0){//画像レイヤーに色が塗ってある場所ならその色を返す
            return RGB2bgColor(r,g,b);    
        }

        var imageLayer = document.getElementById("imageLayer");
            if(!imageLayer || !imageLayer.getContext){
            return '000000';
        }
        var imageLayerCtx = imageLayer.getContext("2d");
        
        var imagedata = imageLayerCtx.getImageData(x, y, 1, 1);
          //  RGBAの取得
        r = imagedata.data[0];
        g = imagedata.data[1];
        b = imagedata.data[2];
        a = imagedata.data[3];
          
        return RGB2bgColor(r,g,b);
      
    }
      
          // RGBからffffff形式へ変換する
    function RGB2bgColor(r,g,b) {
        r = r.toString(16);
        if (r.length == 1) r = "0" + r;
 
            g = g.toString(16);
            if (g.length == 1) g = "0" + g;
         
            b = b.toString(16);
            if (b.length == 1) b = "0" + b;
         
            return r + g + b;  
    }
    
    function timeStamp(){
           var currentDate = new Date();
           if(drawMode == 0 || drawMode == 1){
               drawData = drawData + "#" + currentDate.toLocaleString() + "\n"
           }else{
               paintData = paintData + "#" + currentDate.toLocaleString() + "\n"
           }
    }
        
    function spoitON(){
        if(isSpoit == true){
            spoitOFF();
            return;
        }
        isSpoit = true;
        var canvas = document.getElementById('mycanvas');
        canvas.style.cursor = 'crosshair'
        spoitButtonObj.className = "selected_btn";
        spoitButtonObj.innerHTML = " 色を取得中！ "
    }
    
    function spoitOFF(){
        isSpoit = false;
        spoitButtonObj.className = "normal_btn";
        var canvas = document.getElementById('mycanvas');
        canvas.style.cursor = 'default'
        spoitButtonObj.innerHTML = " 画像の色を取得 "
    }

    function lastPaintON(){
        var lastPaintCanvas = document.getElementById('lastPaintCanvas');
        //クリアする
        var ctx = lastPaintCanvas.getContext('2d');
        ctx.clearRect(0, 0, 640, 480);
        lastPaintCanvas.style.display = 'block';
        //lastPaintCanvas.style.background = '#fdc689';
    }
    function lastPaintOFF(){
        var lastPaintCanvas = document.getElementById('lastPaintCanvas');
        lastPaintCanvas.style.display = 'none';
    }

    function changeDeleteMode(){
        if (isDelete){
            changeDeleteButtonObj.className = "sp_normal_btn";
            isDelete = false;
            lineButtonObj.innerHTML = " 線を引く ";
            paintButtonObj.innerHTML = " 色塗り ";
            afterLineButtonObj.innerHTML = " 後の線を引く ";
            lastPaintButtonObj.innerHTML = " 仕上げ塗り ";
        }else{
            changeDeleteButtonObj.className = "sp_selected_btn";
            isDelete = true;
            lineButtonObj.innerHTML = " 線を消す ";
            paintButtonObj.innerHTML = " 色消し ";
            afterLineButtonObj.innerHTML = " 後の線を消す ";
            lastPaintButtonObj.innerHTML = " 仕上げ消し ";
        }
    }
    
    function changePaintFillMode(){
       		if(isPaintFill){
       			isPaintFill = false;
       			paintFillButtonButtonObj.className = "normal_btn";
                paintFillButtonButtonObj.innerHTML=" 塗らないモード " 
       		}else{
       			isPaintFill = true;
       			paintFillButtonButtonObj.className = "selected_btn";
                paintFillButtonButtonObj.innerHTML=" 塗りつぶしモード " 
       		}
       		redraw();
    }
    
    function undo(){
        if(isDelete){
            return;//Deleteモード中はUndo不可
        }
       	//モードによってどれから消すか。
        switch(drawMode){
            case DMODE_LINE:
           		if(drawDataList.length == 0){
           			return;
       		    }
       		    drawDataList.pop();
                break;
            case DMODE_PAINT:
                if(paintDataList.length == 0){
           			return;
       		    }
       		    paintDataList.pop();
                break;
            case DMODE_AFTER_LINE:
                if(afterDrawDataList.length == 0){
           			return;
       		    }
       		    afterDrawDataList.pop();
                break;
            case DMODE_LAST_PAINT:
                if(lastPaintDataList.length == 0){
           			return;
       		    }
       		    lastPaintDataList.pop();
                break;

        }
        redraw();
    }
        
    function redraw(){
        var canvas = document.getElementById('mycanvas');
            if(!canvas || !canvas.getContext){
            return false;
        }
 
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, 640, 480);

        //白で枠を描く（ペイントはみ出ないための暫定対応）
        ctx.beginPath();
        ctx.strokeStyle = "#FFFFFF";
        ctx.strokeRect(0, 0, 640, 480);
          
        for(idx = 0;idx < drawDataList.length;idx++){
            var drawDataObj = drawDataList[idx];
            var color = drawDataObj.color;
            if(color == 0){
                colorStyle = "black"
            }else{
                colorStyle = "#" + color
            }

            ctx.beginPath();
            startDrawPoint = null;
            endDrawPoint = null;
            ctx.strokeStyle = colorStyle;
            for(lineIdx = 0;lineIdx < drawDataObj.drawData.length;lineIdx++){
                var drawPoint = drawDataObj.drawData[lineIdx];
                if(lineIdx == 0){
                    ctx.moveTo(drawPoint[0], drawPoint[1]);
                    startDrawPoint= drawPoint;
                }else if(lineIdx == drawDataObj.drawData.length - 1){
                    endDrawPoint = drawPoint;
                }
                ctx.lineTo(drawPoint[0], drawPoint[1]);
            }
            ctx.stroke();
              
              //削除モードの時には丸表示予定
              //ctx.beginPath();
              //ctx.fillStyle = colorStyle;
              //if (startDrawPoint != null){
              //    ctx.arc(startDrawPoint[0], startDrawPoint[1], 2, 0, Math.PI*2, false);
              //}
              //if (endDrawPoint != null){
              //    ctx.arc(endDrawPoint[0], endDrawPoint[1], 2, 0, Math.PI*2, false);
              //}
              //ctx.fill();
        }

        for(idx = 0;idx < paintDataList.length;idx++){
            var paintDataObj = paintDataList[idx];
            var color = paintDataObj[0];
            var x =  paintDataObj[1];
            var y =  paintDataObj[2];
            if(isPaintFill){
                //アプリの動作に合わせて、すでに塗ってある場所は塗らない
                var imagedata = ctx.getImageData(x, y, 1, 1);
                //  RGBAの取得
                var r = imagedata.data[0];
                var g = imagedata.data[1];
                var b = imagedata.data[2];
                var a = imagedata.data[3];
                if(r+g+b+a==0){
                    var cfa = new CanvasFillAlgorithm(canvas);
                    cfa.setColorDistance(0);
                    cfa.setAlphaDistance(0);
                    cfa.paint(x, y, getConversionRgba("#" + color));
                }
            }else{
                ctx.beginPath();
                ctx.fillStyle = "#" + color;
                ctx.arc(x, y, 2, 0, Math.PI*2, false);
                ctx.fill();
            }
        }

        if(drawMode == DMODE_AFTER_LINE || drawMode == DMODE_LAST_PAINT){
            for(idx = 0;idx < afterDrawDataList.length;idx++){
                var drawDataObj = afterDrawDataList[idx];
                var color = drawDataObj.color;
                if(color == 0){
                    colorStyle = "black"
                }else{
                    colorStyle = "#" + color
                }
                ctx.beginPath();
                startDrawPoint = null;
                endDrawPoint = null;
                ctx.strokeStyle = colorStyle;
                for(lineIdx = 0;lineIdx < drawDataObj.drawData.length;lineIdx++){
                    var drawPoint = drawDataObj.drawData[lineIdx];
                    if(lineIdx == 0){
                        ctx.moveTo(drawPoint[0], drawPoint[1]);
                        startDrawPoint= drawPoint;
                    }else if(lineIdx == drawDataObj.drawData.length - 1){
                        endDrawPoint = drawPoint;
                    }
                    ctx.lineTo(drawPoint[0], drawPoint[1]);
                }
                ctx.stroke();
            }
        }
        if(drawMode == DMODE_LAST_PAINT){
            for(idx = 0;idx < lastPaintDataList.length;idx++){
                var lastPaintObj = lastPaintDataList[idx];
                var color = lastPaintObj[0];
                if(color == 0){
                    colorStyle = "black"
                }else{
                    colorStyle = "#" + color
                }
                var x1 =  lastPaintObj[1];
                var y1 =  lastPaintObj[2];
                var x2 =  lastPaintObj[3];
                var y2 =  lastPaintObj[4];
                ctx.beginPath();
                ctx.strokeStyle = colorStyle;
                ctx.fillStyle = colorStyle;
                ctx.fillRect(x1,y1,x2-x1,y2-y1);
                ctx.stroke();
            }
        }

    }
       
       
		function getConversionRgba(color_code) {
    		red   = parseInt(color_code.substring(1,3), 16);
    		green = parseInt(color_code.substring(3,5), 16);
    		blue  = parseInt(color_code.substring(5,7), 16);
    		alpha = 255;

	      return (
        	(red   << 24) |
        	(green << 16) |
        	(blue  <<  8) |
        	(alpha      )
      	) >>> 0;
	}

       
      function setColor(color){
          penColor = color;
          selectedColorObj.style.backgroundColor = '#' + color;
          //spoitOFF(); OFFはそれぞれのところで行う
      }  
       
     function changeViewMode(){
		var meta = document.createElement('meta');
		meta.setAttribute('name', 'viewport');
		if(smallMode == true){
			meta.setAttribute('content', 'width=device-width, initial-scale=1');
			smallMode = false;
		}else{
			meta.setAttribute('content', 'width=device-width, initial-scale=0.5');
			smallMode = true;
		}
		document.getElementsByTagName('head')[0].appendChild(meta);
	}       

    
    function getNowYMDHMS(){
        var dt = new Date();
        var y = dt.getFullYear();
        var m = ("0" + (dt.getMonth()+1)).slice(-2);
        var d = ("0" + dt.getDate()).slice(-2);
        var h = ("0" + dt.getHours()).slice(-2);
        var mi = ("0" + dt.getMinutes()).slice(-2);
        var s =  ('0' + dt.getSeconds()).slice(-2);
        var result = y + m + d + h + mi + s;
        return result;
    }

    function deletePoint(x,y){
        if(isDelete == false){
            return;//念のため
        }

        var selectedIdx = -1;
        switch(drawMode){
            case DMODE_LINE:
           		if(drawDataList.length == 0){
           			return;
       		    }
                for(idx = drawDataList.length -1 ;idx >=0; idx--){  //新しいほうから探す
                    var drawDataObj = drawDataList[idx];
                    for(lineIdx = 0;lineIdx < drawDataObj.drawData.length;lineIdx++){
                        var drawPoint = drawDataObj.drawData[lineIdx];
                        if((drawPoint[0] - 3<= x && x <= drawPoint[0] + 3 )&&
                        (drawPoint[1] - 3 <= y &&  y <= drawPoint[1] + 3)){
                            selectedIdx = idx;
                            break;
                        }
                    }
                    if(selectedIdx != -1){
                        break;
                    }
                }
                if(selectedIdx != -1){
                    drawDataList.splice(selectedIdx, 1);
                }

                break;
            case DMODE_PAINT:
                if(paintDataList.length == 0){
           			return;
       		    }
                for(idx = paintDataList.length -1 ;idx >=0; idx--){  //新しいほうから探す
                    var paintDataObj = paintDataList[idx];
                    if((paintDataObj[1] - 3<= x && x <= paintDataObj[1] + 3 )&&
                        (paintDataObj[2] - 3 <= y &&  y <= paintDataObj[2] + 3)){
                        selectedIdx = idx;
                        break;
                    }
                }
                if(selectedIdx != -1){
                    paintDataList.splice(selectedIdx, 1);
                }
                break;
            case DMODE_AFTER_LINE:
                if(afterDrawDataList.length == 0){
           			return;
       		    }
                for(idx = afterDrawDataList.length -1 ;idx >=0; idx--){  //新しいほうから探す
                    var drawDataObj = afterDrawDataList[idx];
                    for(lineIdx = 0;lineIdx < drawDataObj.drawData.length;lineIdx++){
                        var drawPoint = drawDataObj.drawData[lineIdx];
                        if((drawPoint[0] - 5<= x && x <= drawPoint[0] + 5 )&& //色はちょっと大きめで探す
                        (drawPoint[1] - 5 <= y &&  y <= drawPoint[1] + 5)){
                            selectedIdx = idx;
                            break;
                        }
                    }
                    if(selectedIdx != -1){
                        break;
                    }
                }
                if(selectedIdx != -1){
                    afterDrawDataList.splice(selectedIdx, 1);
                }

                break;
            case DMODE_LAST_PAINT:
                if(lastPaintDataList.length == 0){
                    return;
                }
                for(idx = lastPaintDataList.length - 1;idx >=0;idx--){
                    var lastPaintData = lastPaintDataList[idx];
                    //x1,y1,x2,y2 の中にポイントがあれば削除
                    //逆もありうる
                    if((lastPaintData[1] >= x && lastPaintData[3] <=x ||lastPaintData[3] >= x && lastPaintData[1] <=x)
                       &&
                       (lastPaintData[2] >= y && lastPaintData[4] <=y ||lastPaintData[4] >= y && lastPaintData[2] <=y )){
                        selectedIdx = idx;
                            break;
                    }
                }
                if(selectedIdx != -1){
                    lastPaintDataList.splice(selectedIdx, 1);
                }
        }
        redraw();
    }
    function changeImageAlpha(){
        var alphaLayer = document.getElementById("alphaLayer");
            if(!alphaLayer || !alphaLayer.getContext){
            return false;
        }
        var aplhaLayerCtx = alphaLayer.getContext("2d");

        //0:50% 1:100% 2:白背景 4:黒背景
        switch(imageAplhaMode){
            case 0:
                imageAplhaMode = 1;
                imageAlphaButtonObj.innerHTML=" 100% "
                aplhaLayerCtx.clearRect(0, 0, 640, 480);
                break;
            case 1:
                imageAplhaMode = 2;
                imageAlphaButtonObj.innerHTML=" 白背景 "
                aplhaLayerCtx.globalAlpha = 1;
                aplhaLayerCtx.fillStyle = "#" + backGroundColor;
                aplhaLayerCtx.clearRect(0, 0, 640, 480);
                aplhaLayerCtx.fillRect(0, 0, aplhaLayerCtx.canvas.width, aplhaLayerCtx.canvas.height);
                break;
            case 2:
                imageAplhaMode = 3;
                imageAlphaButtonObj.innerHTML=" 黒背景 "
                aplhaLayerCtx.globalAlpha = 1;
                aplhaLayerCtx.fillStyle = "black";
                aplhaLayerCtx.clearRect(0, 0, 640, 480);
                aplhaLayerCtx.fillRect(0, 0, aplhaLayerCtx.canvas.width, aplhaLayerCtx.canvas.height);
                break;
            case 3:
                imageAplhaMode = 0;
                imageAlphaButtonObj.innerHTML=" 50% " //ホントは70%
                aplhaLayerCtx.globalAlpha = 0.7;
                aplhaLayerCtx.fillStyle = "white";
                aplhaLayerCtx.clearRect(0, 0, 640, 480);
                aplhaLayerCtx.fillRect(0, 0, aplhaLayerCtx.canvas.width, aplhaLayerCtx.canvas.height);

                break;
        }

        
    }

    function changeCgTitle(){
        cgTitle = cgTitleForm.value;
    }

    </script>
    <p><pre id="drawData"></pre></p>
    <hr/>
    <input type="button" onClick="changeViewMode()" value="画面サイズ切り替え"/>
</body>
</html>